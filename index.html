<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="content-type" content="text/html" />
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>yxp的博客</title>
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/blog.css">
  <!-- Custom Fonts -->
  <script src="https://use.fontawesome.com/e6b9c39ee7.js"></script>
  <!-- code-prettify from Google -->
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  <link href="/css/atelier-forest-light.min.css" rel="stylesheet">
  <!-- <link href="/css/pretty.css" rel="stylesheet"> -->
  <!-- jQuery -->
  <script src="/js/jquery.min.js "></script>
  <!-- UY 友言评论 -->
  <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2129743"></script>
</head>


<body>
	
<div class="__vue-root" id="Navigator" baseUrl=""
      githubSite="https://github.com/yxping" weiboSite="https://weibo.com/yaoxiaopengweibo"> </div>
<!-- <navigator class="navigator-wrap">
  <div class="navigator-wrap">
    <a class="navigator-blog-name" href="/">YXP Blog</a>
    <button type="button" class="float-icon">
      <span style="width: 0px; height: 0px; margin-bottom: -2px"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
  </div>
  <div id="navigator-menu">
    <div class="navigator-menu-toggle">
        <ul class="menu-ul">
          <li>
            <a href="/">HOME</a>
          </li>
          <li>
            <a href="/">ABOUT</a>
          </li>
          <li>
            <a href="/">GUITAR</a>
          </li>
        </ul>
    </div>
  </div>
</navigator> -->


<script>
  // var $body = document.body;
  // var $navMenu = document.querySelector('#navigator-menu');
  // var $menuBtn = document.querySelector('.float-icon');
  // var $menuToggle = document.querySelector('.navigator-menu-toggle');
  // var _menu_operator = {
  //   open: function() {
  //     $navMenu.className = " in";
  //   },
  //
  //   close: function() {
  //     $navMenu.className = " out";
  //   }
  // };
  // $menuBtn.addEventListener('click', function(e) {
  //   if ($navMenu.className.indexOf('in') > 0) {
  //     _menu_operator.close();
  //   } else {
  //     _menu_operator.open();
  //   }
  // });
  //
  // document.addEventListener('click', function(e){
  //   if ($navMenu.className.indexOf('in') > 0) {
  //     if((e.target == $menuBtn) || (e.target.className == 'icon-bar')) return;
  //     _menu_operator.close();
  //   }
  // })
</script>

	<!-- BlogList -->
<div>
  
  <div class="__vue-root" id="ArticleInfo" postTitle="Android富文本测量绘制实践优化" postUrl="/post/Android富文本测量绘制实践优化.html"
        postDate="April 2, 2017" postSynopsis="在动态化跨平台实践的背景下，文字的测量和绘制依赖于BoringLayout、StaticLayout和TextView对于文本的处理，方式是在子线程进行测量，UI线程进行绘制。这种方式解决在给定Rect中依赖UI线程（TextView）获取文字排版问题，但是使用这种方式会引起排版不一致和排版缓慢问题，文章阐述了对于上述问题的处理，同时进行文字测量和富文本相关内容。"
        postSubTitle="" postContent="<p>文字的排版和绘制是一件极其复杂的工序，尤其是面对富文本的操作。Android 系统提供了 SpannableString 和 andoird.text.Layout 可以简化对于富文本操作的难度，下面的内容就是围绕这两个类进行相关的描述，<strong>针对如何进行文字的正确测量和优化绘制展开。</strong></p>
<h3 id="文本测量--绘制">文本测量 &amp; 绘制</h3>
<p>了解文本测量的方式，最直接的就是看 TextView 的源码。我是通过结合了 TextView 源码、ReactNative 的 ReactTextShadowNode 和 Weex 的 WXTextDomObject 进行这一次的文本优化策略的实践。</p>

<p><em>当然对于纯文本的测量可以通过 Paint.getTextBounds 和 Paint.measureText 方法，两者底层调用的skia方法是相同的，只是返回的精度不同，具体用法和区别可以参考 <a href="http://stackoverflow.com/questions/7549182/android-paint-measuretext-vs-gettextbounds">stackoverflow</a></em></p>

<blockquote>
  <h4 id="1-layout认识">1. Layout认识</h4>
  <p>Android 提供了三种对于文字的布局测量类，分别是 BoringLayout , StaticLayout , DynamicLayout 。</p>
  <ul>
    <li><strong>BoringLayout</strong> : 对于没有任何的 ParagraphStyle 修饰的单行文本（ text 或者 span）的测量工具。</li>
    <li><strong>StaticLayout</strong> : 对于静态不变文本的测量工具。可以处理多种 span 效果，是最主要的测量文本布局工具。</li>
    <li><strong>DynamicLayout</strong> : 对于动态可变文本的测量工具。配合 SpannableStringBuilder 使用，内部使用 ChangeWatcher 监听 SpannableStringBuilder 文本的变化，动态更新 Layout。 DynamicLayout 内部实现仍然使用的是 StaticLayout 。</li>
  </ul>
</blockquote>

<blockquote>
  <p><em>ParagraphStyle 是众多 span 的其中一个文本格式，span 的基本文本格式和作用如下</em></p>
  <ul>
    <li><em>CharacterStyle</em> : 指定文本中每一个字符的格式。</li>
    <li><em>ParagraphStyle</em> : 指定一段/行文本的文字格式</li>
    <li><em>UpdateApperarance</em> : 动态指定一个字符的格式</li>
  </ul>
</blockquote>

<blockquote>
  <h4 id="2-文本高度认识">2. 文本高度认识</h4>
  <p>Layout 的测量需要依赖于 TextPaint, 通过 StaticLayout 源码可以明白，在使用 MeasuredText 获取每段文本高度的时候，使用 TextPaint 。利用在 Paint.FontMetrics 类中定义的 top, ascent, descent, bottom, leading 五个变量对文本的高度进行描述。
<img src="/images/staticlayout1.png" alt="Drawing" style="width: 400px;" />
上面这个图就是五个变量所描述的位置，在进行行高设置的时候可以通过 LineHeightSpan 对这些参数进行修改达到效果。这个的实现方式和源码在下一个小点上展开。</p>
  <ul>
    <li>Baseline: 指的位置是 paint 绘制text的基准线</li>
    <li>Top: 在给定大小的最高字体的基线以上的最大距离，为负数（在 vivo 上的表现是 top 小于 ascent，坑爹，不过不影响计算）</li>
    <li>Ascent: 在单行文本的基线以上的推荐距离，为负数，只作用于首行</li>
    <li>Descent: 在单行文本基线以下的推荐距离，为正数，只作用与末行</li>
    <li>Bottom: 在给定大小的最低字体的基线以下的最大距离，为正数</li>
    <li>Leading(没有展示): 推荐的行间距
在 StaticLayout 中可以通过 includepad 变量指定文字高度是以最大距离展示还是以推荐距离展示。展示的效果如上图，第一行是当 includepad = false 的时候，以 ascent 和 descent 为行高，当 includepad = true 的时候，以 top 和 bottom 为行高。具体源码如下：</li>
  </ul>
  <pre class="prettyprint lang-java linenums ">public void out() {
    ...
    if (chooseHt != null) {
        ...
        // above 是 paint 进行绘制的距离 baseline 以上的指定距离
        above = fm.ascent;
        // below 是 paint 进行绘制的距离 baseline 以下的指定距离
        below = fm.descent;
        top = fm.top;
        bottom = fm.bottom;
    }
    ...
    if (firstLine) {
        if (trackPad) {
            mTopPadding = top - above;
        }
        if (includePad) {
            above = top;
        }
    }
    int extra;
    if (lastLine) {
        if (trackPad) {
            mBottomPadding = bottom - below;
        }
        if (includePad) {
            below = bottom;
        }
    }
    ...
}</pre>
</blockquote>

<blockquote>
  <h4 id="3-富文本测量--绘制">3. 富文本测量 &amp; 绘制</h4>
  <p>对 Layout 和文本高度有所了解之后，就可以来用代码实践一下了，就按照上面图片的案例 demo 分析一下富文本测量和绘制的具体方法。</p>
</blockquote>

<blockquote>
  <p><strong>首先：</strong> 构造一个富文本 SpannableStringBuilder (这里也可以用 SpannableString ) ，预先向 SpannableString 设置文本中每一段文字的样式，这样就完成了一个富文本的构造。其中使用了 MyLineHeightSpan 进行 FontMetrics 的五个变量的记录，方便在之后的 onDraw 的时候使用，它调用的时机是在进行 StaticLayout 对于文本进行测量。</p>
  <pre class="prettyprint lang-java linenums ">private SpannableStringBuilder createSpannableString(String text) {
    SpannableStringBuilder sb = new SpannableStringBuilder(text);
    // TODO(5837930): Investigate whether it's worth optimizing this part and do it if so
    // The {@link SpannableStringBuilder} implementation require setSpan operation to be called
    // up-to-bottom, otherwise all the spannables that are withing the region for which one may set
    // a new spannable will be wiped out
    List<SetSpanOperation> ops = new ArrayList&lt;&gt;();
    int start = 0;
    int end = sb.length();
    if (end &gt;= start) {
        // 设置文字大小
        ops.add(new SetSpanOperation(start, end, new AbsoluteSizeSpan((int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_SP, 56, getContext().getResources().getDisplayMetrics()))));
        // 设置文字颜色
        ops.add(new SetSpanOperation(start, end, new ForegroundColorSpan(Color.WHITE)));
        // 设置背景颜色
        ops.add(new SetSpanOperation(start, end, new BackgroundColorSpan(Color.parseColor("#55AA88"))));
        // 设置排版方向
        ops.add(new SetSpanOperation(start, end, new AlignmentSpan.Standard(Layout.Alignment.ALIGN_NORMAL)));
        // 设置行高
        ops.add(new SetSpanOperation(start, end, new MyLineHeightSpan(this)));
        // 设置文字样式分别有 UnderlineSpan (下划线)和 StrikethroughSpan (删除线)
//            ops.add(new SetSpanOperation(start, end, new UnderlineSpan()));
    }
    for (int i = ops.size() - 1; i &gt;= 0; i--) {
        SetSpanOperation op = ops.get(i);
        op.execute(sb);
    }
    return sb;
}
// 记录 FontMetrics ，和上述源码中的 includepad 参数对于文本绘制的影响逻辑一直
void setFontMetrics(int start, int end, Paint.FontMetricsInt fm) {
    mTop = fm.top;
    mBottom = fm.bottom;
    mAscent = fm.ascent;
    mDescent = fm.descent;
    // Is first line
    if (mIncludePad &amp;&amp; start == 0) {
        mAbove = mTop;
    } else {
        mAbove = mAscent;
    }
    // Is last line
    if (mIncludePad &amp;&amp; end == mText.length()) {
        mBelow = mBottom;
    } else {
        mBelow = mDescent;
    }
    mBaseline = 0;
    transform();
}
// 转化成 onDraw 可以进行正确绘制的位置
private void transform() {
    mBaseline = -mAbove;
    mBelow += mBaseline;
    mAbove = 0;
    mTop += mBaseline;
    mAscent += mBaseline;
    mBottom += mBaseline;
    mDescent += mBaseline;
}
static class SetSpanOperation {
    protected int start, end;
    protected Object what;
    // 该 span 作用于从 start 到 end 的一段文本
    SetSpanOperation(int start, int end, Object what) {
        this.start = start;
        this.end = end;
        this.what = what;
    }
    public void execute(SpannableStringBuilder sb) {
        // All spans will automatically extend to the right of the text, but not the left - except
        // for spans that start at the beginning of the text.
        int spanFlags = Spannable.SPAN_EXCLUSIVE_INCLUSIVE;
        if (start == 0) {
            spanFlags = Spannable.SPAN_INCLUSIVE_INCLUSIVE;
        }
        sb.setSpan(what, start, end, spanFlags);
    }
}
// 设置每一行的行高
static class MyLineHeightSpan implements LineHeightSpan {
    private WeakReference<MyTextView> mView;
    public MyLineHeightSpan(MyTextView view) {
        mView = new WeakReference<MyTextView>(view);
    }
    @Override
    public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int v, Paint.FontMetricsInt fm) {
        Log.e("yxp", fm.toString());
        mView.get().setFontMetrics(start, end, fm);
    }
}
</MyTextView></MyTextView></SetSpanOperation></pre>
</blockquote>

<blockquote>
  <p><strong>接着：</strong> 在完成富文本构建后，就可以进行文本的测量，这里分成两大步，一是获取宽度，二是获取高度</p>
  <ul>
    <li>如果文本宽度指定了，则使用指定文本宽度</li>
    <li>如果文本是符合一个 Boring 文本，则使用 BoringLayout.Metrics 提供的 width</li>
    <li>否则使用 Layout.getDesireWidth 进行宽度测量</li>
    <li>构建 StaticLayout 获取文本高度相关变量, includepad 问题可以见上述 <a href="#2-文本高度认识">文本高度认识</a></li>
  </ul>
</blockquote>

<blockquote>
  <p>StaticLayout 是更常使用的测量工具，相对于 BoringLayout 和 DynamicLayout，掌握了 StaticLayout 对于其他两个的使用也是易如反掌，所以这里只展示 StaticLayout 的具体使用方式。</p>
  <pre class="prettyprint lang-java linenums ">protected void initLayout(boolean includepad) {
    mIncludePad = includepad;
    TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
    // 构建富文本
    SpannableStringBuilder span = createSpannableString(mText);
    int desiredWidth;
    if (mGivenWidth != UNSET) {
        desiredWidth = mGivenWidth;
    } else {
        BoringLayout.Metrics isBoring = BoringLayout.isBoring(span, textPaint);
        if (isBoring != null) {
            desiredWidth = isBoring.width;
        } else {
            desiredWidth = (int) Math.ceil(Layout.getDesiredWidth(span, textPaint));
        }
    }
    // 构建 StaticLayout
    mLayout = new StaticLayout(
            // 指定文本，可以是 String 或者 SpannableString
            span,
            // 文本起始位置
            0,
            // 文本终止位置
            span.length(),
            textPaint,
            desiredWidth,
            Layout.Alignment.ALIGN_NORMAL,
            // 字体大小的缩放因子，影响行高
            1,
            // 默认行间距
            0,
            // 影响行高，如上述“文本高度认识”所述
            includepad
    );
}
// onMeasure 时候设置 view 的宽度和高度
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int width = MeasureSpec.makeMeasureSpec(mLayout.getWidth() + 2 * mReservedSpace, MeasureSpec.EXACTLY);
    int height = MeasureSpec.makeMeasureSpec(mLayout.getHeight() + 2 * mReservedSpace, MeasureSpec.EXACTLY);
    super.onMeasure(width, height);
}
</pre>
</blockquote>

<blockquote>
  <p><strong>最后：</strong> 绘制是一个最简单的步骤了，一个 api 调用一下即可绘制。demo 里把五个标准线绘制了出来。代码如下：</p>
  <pre class="prettyprint lang-java linenums ">@Override
protected void onDraw(Canvas canvas) {
    canvas.save();
    canvas.translate(mReservedSpace, mReservedSpace);
    // 文本绘制
    mLayout.draw(canvas);
    // 绘制基线
    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    paint.setStrokeWidth(3);
    paint.setColor(Color.MAGENTA);
    canvas.drawLine(0, mTop, mLayout.getWidth(), mTop, paint);
    paint.setColor(Color.GREEN);
    canvas.drawLine(0, mAscent, mLayout.getWidth(), mAscent, paint);
    paint.setColor(Color.RED);
    canvas.drawLine(0, mBaseline, mLayout.getWidth(), mBaseline, paint);
    paint.setColor(Color.BLUE);
    canvas.drawLine(0, mDescent, mLayout.getWidth(), mDescent, paint);
    paint.setColor(Color.YELLOW);
    canvas.drawLine(0, mBelow, mLayout.getWidth(), mBelow, paint);
    //
    canvas.restore();
}
</pre>
</blockquote>

<blockquote>
  <p>效果图 <img src="/images/staticlayout1.png" alt="Drawing" style="width: 400px;" /></p>
</blockquote>

<h3 id="问题解决方法">问题&amp;解决方法</h3>
<blockquote>
  <p>1.<strong>文本测量和 TextView 测量结果不一致</strong></p>
</blockquote>

<p>  避免使用 TextView，既然自己测量的，就自己绘制，没必要测量完了之后，再通过 TextView 进行设置属性，重复测量，再进行绘制。同时测量自己可以把控，结果当然也是自己把控。demo 的实例的 MyTextView 就是直接继承 View，相关的设置都通过 Span 进行富文本构建。</p>

<blockquote>
  <p>2.<strong>在长文本情况下，onDraw 方法绘制速度比 TextView 慢</strong></p>
</blockquote>

<p>  可以看到在 demo 中对于文字大小和颜色都是通过 Span 进行设置的，然而在 TextView 源码中，对于文字颜色和大小的设置是通过 TextPaint 设置的，应用 TextView 的方法，速度果然提升了，比 TextView onDraw时间快了40%。<em>但是这个当然是有局限的，只能对整一段文字进行使用，如果需要对某一段文字设置的话，还是通过 Span 进行设置会更方便。</em>
  另外，在 <a href="http://www.qingpingshan.com/rjbc/az/119668.html">Weex 的文章</a>中看到了 TextLayoutCache 的缓存问题，在 <a href="http://stackoverflow.com/questions/17449835/tag-textlayoutcache-text-cache-value-deleted">statckoverflow</a> 中对于这个有更详细的描述，大意思可以先通过一个 canvas 进行预先绘制，在底层会通过 LRUCache 进行文本渲染结果缓存，降低下一次绘制的时间。<em>如果排版测量是在另外一条线程，且对于时间没有要求，可以通过这个方式进行预加载，减少 ui 线程的 onDraw 时间，在我的实践中没有使用主要是因为 js 线程和 ui 线程都影响首屏加载，所以无论放在哪里，耗时都是差不多。</em></p>

<blockquote>
  <p>3.<strong>ellipsis问题</strong></p>
</blockquote>

<p>  在 Android api 23之后，StaticLayout 使用了 builder 模式进行构建，可以设置 ellipsis 模式和行数。在23之前的版本，行数的设置是对外隐藏的，也就没办法进行 ellipsis 的操作。所以这个需要自己进行处理。这个的处理方式就是在末尾添加省略号，重新排版问题。分为以下几个步骤：</p>
<ul>
  <li>删除从指定行数到最后的文字，插入省略号</li>
  <li>删除当前行末尾与省略号大小相同或大于的文字</li>
  <li>重新排版测量</li>
</ul>

<p>这里考虑一个性能问题，主要是在 Layout.getDesiredWidth 中是一个 O(N) 时间复杂度，所以使用它的时候不要用遍历的方式，否则会变成 O(N2)，这里通过从最接近的行数往回测量出省略号的距离，只进行单个文字测量，使得时间在 O(1)复杂度。</p>
<pre class="prettyprint lang-java linenums ">protected void initLayout(boolean includepad) {
    ...
    // Determine if need ellipsis
    if (mLineNum != UNSET &amp;&amp; mLayout.getLineCount() &gt; mLineNum) {
        mLayout = ellipsis(span, mLayout, textPaint);
    }
}
public Layout ellipsis(SpannableStringBuilder span, Layout originLayout, TextPaint textPaint) {
    // 删除从指定行数到最后的文字，插入省略号
    span.delete(originLayout.getLineEnd(mLineNum - 1), span.length())
            .insert(span.length(), ELLIPSIS);
    int ellipsisIndex = span.length() - 1;
    // 获取省略号大小
    float ellipsisSize = Layout.getDesiredWidth(span, ellipsisIndex,
            ellipsisIndex + 1, textPaint);
    if (ellipsisSize &gt; originLayout.getWidth()) {
        span.clear();
    } else {
        // 删除当前行末尾与省略号大小相同或大于的文字
        int to = ellipsisIndex - 1;
        int from = to;
        float targetSize = 0;
        while (from &gt; 0) {
            targetSize += Layout.getDesiredWidth(span, from,
                    from + 1, textPaint);
            if (targetSize &gt;= ellipsisSize) {
                break;
            }
            from--;
        }
        if (from == 0) {
            span.clear();
        } else {
            span.delete(from, to + 1);
        }
    }
    // 重新排版
    return new StaticLayout(
            span,
            0,
            span.length(),
            textPaint,
            originLayout.getWidth(),
            Layout.Alignment.ALIGN_NORMAL,
            1,
            0,
            false);
}</pre>

<p>效果图：<img src="/images/staticlayout2.png" alt="Drawing" style="width: 200px;" /></p>
" >
  </div>
  
  <div class="__vue-root" id="ArticleInfo" postTitle="NativeScript构建js和Android的桥梁" postUrl="/post/NativeScript构建js和Android的桥梁.html"
        postDate="April 1, 2017" postSynopsis="NativeScript是一个优秀的开源动态化跨平台框架，它基于了js开发Android应用的基础能力。文章将阐述在Android上NativeScript对于js和Android通过v8虚拟机的交互实现，同时也了解NativeScript的强大之处。"
        postSubTitle="" postContent="<h3 id="前言">前言：</h3>
<p>在React的热浪中，许多优秀的概念喷涌而出，感谢facebook带来的新的概念。最值得关注的就是今年非常火爆的ReactNative框架，learn once, write anywhere. 让js变得异常强大，可以跑在web,ios,android三端，尽管有一定的学习成本，但其强大的开发者库，以及优秀的体验，足以征服无数开发者。</p>

<p>本篇文章主要分析js与Android的交互框架NativeScript中的android-runtime框架，借此可以了解在android端打造ReactNative的基础——Android与js通信的问题。</p>

<p>NativeScript将三端代码放到了不同的仓库，<a href="https://github.com/NativeScript/NativeScript">前端框架链</a>接、<a href="https://github.com/NativeScript/android-runtime">Android框架链接</a>、<a href="https://github.com/NativeScript/ios-runtime">IOS框架链接</a>。</p>

<p><strong><em>对于android-runtime框架，涉及到了v8引擎，从java层到native层，再到js层，需要对三端有一定的了解，文章中介绍nativeScript核心运行时原理（包含java，ndk和js），关于bingding-generator将java类进行二进制化，并一次性注入v8中，使v8可以获得所有类的调用能力的问题，此篇不展开。</em></strong></p>

<p>要了解android-runtime（理解一个框架最快就是从excample中提供的一个入口节点，去摸索框架其中的原理），先将demo跑起来看看效果，demo入口在test-app中。跑起来的时候一开始白屏了，那是在进行js的api test，等一下就可以看到真正的内容，可以体会到写着js在Android中跑起来的快感（虽然webview也可以运行js一样爽快-。-，但是这可是原生界面），android-runtime下的工程有很多个，本篇介绍的工程集中在runtime文件夹下。</p>

<p>看完了demo的效果之后，应该进入框架的研究了，看了demo后应该带着如下几个问题去探索：</p>
<ul>
  <li>JS如何调用Android，这里隐含了js如何调用C，C如何调用Android？</li>
  <li>Android如何调用JS，这里隐含了Android如何调用C，C如何调用JS？</li>
  <li>参数怎么互相转化的？</li>
  <li>JS怎么知道Android有哪些类？</li>
  <li>怎么将js的对象和android的对象进行绑定?</li>
</ul>

<p>这几个问题里面都涉及了google V8引擎。下面带着问题来开始旅程。</p>

<h3 id="整体">整体</h3>
<p>首先先从整体上看android-runtime的框架：(这可以等流程了解了再来看，会更加清楚）
<img src="http://yxping.github.io/images/favicon.ico" alt="whole" />
整体上分了四层，通信的方向正如图中所给的箭头，从最上层的JS通过v8传递给jni，再由jni传递给android，反之亦然。</p>
<ol>
  <li>java层：做好runtime初始化的所有资源准备，包括提取资源，类加载工具，调试工具，对象类型判断，对象保存（保存于js对应的对象，防止被回收找不到）</li>
  <li>jni层：接入v8的api，将js调用传出的方法，转化传递给Android，其中最特别的是，能将参数对应的Object转化成java成对象。</li>
  <li>v8层：将js的方法通过回调方式传递给jni</li>
  <li>js层：页面js逻辑</li>
</ol>

<h4 id="java层">java层</h4>
<p>下载demo源码，一起跟着源码从demo的入口开始，从NativeScriptApplication.onCreate和assets/MyApp.js开始阅读，test部分可以暂时放置。
一个整体的初始化流程图如下：
<img src="http://yxping.github.io/images/favicon.ico" alt="initwhole" /></p>
<ol>
  <li>NativeScriptApplication通过RuntimeHelper初始化Runtime，
在RuntimeHelper.initRuntime方法中，包括了AndroidJSDebugger（调试工具类），NativeScriptUncaughtExceptionHandler（异常捕获类），Extractor（文件提取工具类），Configuration（Runtime配置类），NativeScriptLiveSync（与本地服务器进行文件同步工具）的初始化。</li>
</ol>

<p>其中文件提取工具类主要作用是解压assets文件，提取js和metadata文件：
<img src="http://note.youdao.com/favicon.ico" alt="assets" /></p>
<ul>
  <li>解压assets的作用：由于assets文件中存有基础的js文件和metadata文件（比较大），将assets解压到本地，就不用每次都去通过assets去读取，因为assets读取时相当于解压apk去找资源拿出来一样，每次读取会降低效率，存在本地会减少读取时间，增加效率。</li>
  <li>ExtractPolicy：是解压assets的一个判断标准，利用assetsThumb（包的版本和安装时间拼凑的字符串，详细可见generateAssetsThumb方法）判断是否需要解压和是否需要覆盖文件。</li>
  <li>FileExtractor：利用AssetsExtractor.cpp进行assets提取，这里的提取方式是通过c++的zip解压方式提取assets中的文件。</li>
</ul>

<p>当基础的类初始化后，进入runtime的初始化，如下代码所示：
Runtime.java</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">runtimeId</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">nextRuntimeId</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">// Runtime是线程安全的，一个ThreadLoacal保存着自己的Runtime</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Runtime</span><span class="o">&gt;</span> <span class="n">currentRuntime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Runtime</span><span class="o">&gt;();</span>
<span class="c1">// 提供多个runtime的缓存</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Runtime</span><span class="o">&gt;</span> <span class="n">runtimeCache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Runtime</span><span class="o">&gt;();</span>

<span class="c1">// 在这里的ThreadScheduler是主线程，也可以移植到其他线程</span>
<span class="kd">public</span> <span class="nf">Runtime</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">config</span><span class="o">,</span> <span class="n">ThreadScheduler</span> <span class="n">threadScheduler</span><span class="o">)</span>
<span class="o">{</span>
	<span class="kd">synchronized</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">currentRuntime</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="n">Runtime</span> <span class="n">existingRuntime</span> <span class="o">=</span> <span class="n">currentRuntime</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">existingRuntime</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
		<span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">NativeScriptException</span><span class="o">(</span><span class="s">"There is an existing runtime on this thread with id="</span> <span class="o">+</span> <span class="n">existingRuntime</span><span class="o">.</span><span class="na">getRuntimeId</span><span class="o">());</span>
		<span class="o">}</span>
		<span class="k">this</span><span class="o">.</span><span class="na">runtimeId</span> <span class="o">=</span> <span class="n">nextRuntimeId</span><span class="o">++;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">config</span> <span class="o">=</span> <span class="n">config</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">threadScheduler</span> <span class="o">=</span> <span class="n">threadScheduler</span><span class="o">;</span>
		<span class="c1">// 类解析器</span>
		<span class="n">classResolver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassResolver</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
		<span class="n">currentRuntime</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
		<span class="n">runtimeCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">runtimeId</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<ol>
  <li>接着调用jni的对应的runtime.cpp的initNativeScript方法（此方法在jni层进行介绍，主要是开启v8），到这里<strong>完成了java层的runtime和jni层的runtime的初始化</strong>。
接下来就是注入js中的拓展能力的工具类——ts_helper.js</li>
</ol>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">runtime</span><span class="o">.</span><span class="na">runScript</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">appDir</span><span class="o">,</span> <span class="s">"internal/ts_helpers.js"</span><span class="o">));</span>
</code></pre>
</div>

<p>此js的作用包括判断是否是一个extend之后的js对象，通过判断__proto__是不是具有Parent，还有使得js对象具备继承的能力，例如MyActivity.js：</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">MyActivity</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">__extends</span><span class="p">(</span><span class="nx">MyActivity</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
    <span class="kd">function</span> <span class="nx">MyActivity</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_super</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span><span class="c1">// 省略中间部分</span>
    <span class="c1">// 将activity元素与NativeScriptActivity绑定，创建android的NativeScriptActivity对象时，</span>
    <span class="c1">// 对应创建的js对象就会转到当前所定义的拓展元素中</span>
    <span class="nx">MyActivity</span> <span class="o">=</span> <span class="nx">__decorate</span><span class="p">([</span>
        <span class="nx">JavaProxy</span><span class="p">(</span><span class="s2">"com.tns.NativeScriptActivity"</span><span class="p">)</span>
    <span class="p">],</span> <span class="nx">MyActivity</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">MyActivity</span><span class="p">;</span>
<span class="p">})(</span><span class="nx">android</span><span class="p">.</span><span class="nx">app</span><span class="p">.</span><span class="nx">Activity</span><span class="p">);</span>
</code></pre>
</div>

<ol>
  <li>接下来就是向runtime中注入类绑定的js文件（NativeScriptActivity利用了注解绑定了MyApp.js），MyApp.js的作用使创建一个MyApp对象，注入绑定js的方法是通过Runtime.initInstance(Object)方法。</li>
</ol>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// 初始化js对象</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">initInstance</span><span class="o">(</span><span class="n">Object</span> <span class="n">instance</span><span class="o">)</span>
<span class="o">{</span>
    <span class="c1">// 获取当前线程的runtime对象</span>
	<span class="n">Runtime</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getCurrentRuntime</span><span class="o">();</span>
	<span class="c1">// 获取runtime id均为-1</span>
	<span class="kt">int</span> <span class="n">objectId</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="na">currentObjectId</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">objectId</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="n">runtime</span><span class="o">.</span><span class="na">makeInstanceStrong</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">objectId</span><span class="o">);</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="n">runtime</span><span class="o">.</span><span class="na">createJSInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 由android对象创建js对象</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">createJSInstance</span><span class="o">(</span><span class="n">Object</span> <span class="n">instance</span><span class="o">)</span>
<span class="o">{</span>
    <span class="c1">// 在jni层生层js对象的id</span>
	<span class="kt">int</span> <span class="n">javaObjectID</span> <span class="o">=</span> <span class="n">generateNewObjectId</span><span class="o">(</span><span class="n">getRuntimeId</span><span class="o">());</span>
    <span class="c1">// 将android对象和js对象id移入强缓存区，由此可以推测出，**js对象和android的对象是通过id进行绑定的**</span>
	<span class="n">makeInstanceStrong</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">javaObjectID</span><span class="o">);</span>
	<span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
	<span class="c1">// 如果不曾加载此使用extends进行拓展的js文件，则进行module的注入，在底层就是利用js的require将js文件引入，</span>
	<span class="c1">// 方便创建对象的时候，是使用该extend对象进行创建，此时的js的对象就具备有了require进来的对象的扩展能力。</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">loadedJavaScriptExtends</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">clazz</span><span class="o">))</span>
	<span class="o">{</span>
		<span class="n">JavaScriptImplementation</span> <span class="n">jsImpl</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">JavaScriptImplementation</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">jsImpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
		<span class="o">{</span>
			<span class="n">File</span> <span class="n">jsFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">jsImpl</span><span class="o">.</span><span class="na">javaScriptFile</span><span class="o">());</span>
			<span class="c1">// 加载注解中指定的js文件，使用js中的require加入。</span>
			<span class="c1">// 在运行该段js的时候，在metadata中会将该.extend的对象缓存起来（MetadataNode.cpp中的SetStaticMembers函数）</span>
			<span class="c1">// 则当创建该类的js对象的时候，都会创建该extend后的js对象</span>
			<span class="n">runModule</span><span class="o">(</span><span class="n">jsFile</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">loadedJavaScriptExtends</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">jsImpl</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    <span class="c1">// 通过底层创建js对象</span>
	<span class="n">createJSInstanceNative</span><span class="o">(</span><span class="n">getRuntimeId</span><span class="o">(),</span> <span class="n">instance</span><span class="o">,</span> <span class="n">javaObjectID</span><span class="o">,</span> <span class="n">className</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isEnabled</span><span class="o">())</span>
		<span class="n">logger</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"JSInstance for "</span> <span class="o">+</span> <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">" created with overrides"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>可能还会有点不解的是，为啥要使用新的js文件注入，举个例子，NativeScriptApplication为啥还要用MyApp.js，不是可以直接在js中创建一个与NativeScriptApplication绑定的js对象了吗？主要是因为不经过extend处理的js对象没有拓展能力，只能调到原生的android对象的方法。如下（MyApp.js和MyActivity.js意义相同）：
MyApp.js</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// demonstrates how to extend class in JavaScript with prebuilt Java proxy</span>
<span class="kd">var</span> <span class="nx">MyApp</span> <span class="o">=</span> <span class="nx">android</span><span class="p">.</span><span class="nx">app</span><span class="p">.</span><span class="nx">Application</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="s2">"com.tns.NativeScriptApplication"</span><span class="p">,</span>
<span class="p">{</span>
    <span class="c1">// 通过extend之后，js对象的onCreate方法可以进行自己的操作，当从NativeScriptApplication中调用</span>
    <span class="c1">// com.tns.Runtime.callJSMethod(this, "onCreate", void.class, args)的方法（和NativeScriptActivity类似）的时候</span>
    <span class="c1">// 就可以调用到该js拓展对象的onCreate方法中</span>
	<span class="na">onCreate</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="nx">__log</span><span class="p">(</span><span class="s2">"Hello MyApp::onCreate()"</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>

<ol>
  <li>NativeScriptActivity调用onCreate方法，调用到js中的onCreate方法中去创建android的ui元素</li>
</ol>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@JavaScriptImplementation</span><span class="o">(</span><span class="n">javaScriptFile</span> <span class="o">=</span> <span class="s">"./MyActivity.js"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NativeScriptActivity</span> <span class="kd">extends</span> <span class="n">android</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">Activity</span>
<span class="o">{</span>
	<span class="kd">public</span> <span class="nf">NativeScriptActivity</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="n">com</span><span class="o">.</span><span class="na">tns</span><span class="o">.</span><span class="na">Runtime</span><span class="o">.</span><span class="na">initInstance</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Bundle</span> <span class="n">param_0</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="n">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">param_0</span><span class="o">;</span>
		<span class="n">com</span><span class="o">.</span><span class="na">tns</span><span class="o">.</span><span class="na">Runtime</span><span class="o">.</span><span class="na">callJSMethod</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">"onCreate"</span><span class="o">,</span> <span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>小结：
java层的代码包括了test-app项目和runtime核心项目的部分大体已经分析的差不多了。其他都是一些辅助的类，当大体流程了解了，这些辅助类也就能触类旁通了。这里总结遇到的几点方法：</p>
<ol>
  <li>在java层调用js方法是通过Runtime.callJsMethod()方法调用。</li>
  <li>在java层创建js对象是通过Runtime.initJsInstance()方法调用。</li>
  <li>回到刚刚提出的问题，“怎么将js的对象和android的对象进行绑定?”，从刚刚的分析上可以得出是利用id将js对象和android对象进行绑定，存储到一个map中。</li>
  <li>加载流程是：初始化runtime-&gt;加载基础js-&gt;加载页面逻辑js。</li>
</ol>

<h4 id="jni层">jni层</h4>
<p>jni层承担的责任是构建android和js通信的桥梁，也可以说是两者进行交流的语言转换器（进行参数转化）。在jni层有三个部分组成参数转化，对象管理，函数回调。在这一核心层中，做的事情比较多，但是总的来说就是就是以上上三个主要点。在这篇博客中也是对于runtime核心进行提取，提取出最主要的流程和方法，其余的细节部分需要根据源码再进行琢磨。</p>

<p>这里主要涉及几个类文件，ObjectManager.cpp、Runtime.cpp、CallbackHandler.cpp、JsArgConvector.cpp、ArgConvector.cpp、MetadataNode.cpp，这几个类就可以打通整一套通信机制。</p>

<p>这里分为两个模块进行runtime进行的工作的描述：
1.Android与JS间对象创建和绑定：<br />
<img src="http://note.youdao.com/favicon.ico" alt="对象的创建和绑定" /><br />
这里有两个渠道可以创建对象，两个渠道的意思是指js可以创建对象，同时会生成一个android对象；android可以创建对象，同时会生成一个js对象。对于NativeScript来说，由于是提供给前端去进行Android端的开发，所以对外所知道的是js能够对应的产生android对象，所以在进行Js编写的时候感受不到android能够创建js对象。但这个框架的能力很强的，就在于runtime这一层将js和android的行为变得一一对应（神乎其技，其实神的是v8）。我们就以两个example来了解创建对象的一个机制。</p>

<p>(1)从JS端创建一个Android端的MyActivity对应的NativeScriptActivity：
创建js的对象不是很简单吗？通过runscript去执行一个var a = {}，这个就是一个对象啦，但是这并不能和android的对象一一对应，下面来看下NativeScript是怎么做的。
在上面java层的第3点中讲到了通过注解注入绑定的js文件，在此之后进行了初始化创建。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="o">(!</span><span class="n">loadedJavaScriptExtends</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">clazz</span><span class="o">))</span>
<span class="o">{</span>
	<span class="n">JavaScriptImplementation</span> <span class="n">jsImpl</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">JavaScriptImplementation</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">jsImpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="n">File</span> <span class="n">jsFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">jsImpl</span><span class="o">.</span><span class="na">javaScriptFile</span><span class="o">());</span>
		<span class="c1">// 注入js扩展类</span>
		<span class="n">runModule</span><span class="o">(</span><span class="n">jsFile</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="n">loadedJavaScriptExtends</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">jsImpl</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
<span class="c1">// 创建javaobj对应的js对象</span>
<span class="n">createJSInstanceNative</span><span class="o">(</span><span class="n">getRuntimeId</span><span class="o">(),</span> <span class="n">instance</span><span class="o">,</span> <span class="n">javaObjectID</span><span class="o">,</span> <span class="n">className</span><span class="o">);</span>
</code></pre>
</div>

<p>在runModule时候会对应的创建了一个extend扩展了android.app.Activity的MyActivity，从而在初始化对应的android.app.Activity的时候会创建出对应的拓展MyActivity对象。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">MyActivity</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">__extends</span><span class="p">(</span><span class="nx">MyActivity</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
    <span class="kd">function</span> <span class="nx">MyActivity</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_super</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="err">······</span>
    <span class="nx">MyActivity</span> <span class="o">=</span> <span class="nx">__decorate</span><span class="p">([</span>
        <span class="nx">JavaProxy</span><span class="p">(</span><span class="s2">"com.tns.NativeScriptActivity"</span><span class="p">)</span>
    <span class="p">],</span> <span class="nx">MyActivity</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">MyActivity</span><span class="p">;</span>
<span class="p">})(</span><span class="nx">android</span><span class="p">.</span><span class="nx">app</span><span class="p">.</span><span class="nx">Activity</span><span class="p">);</span>
</code></pre>
</div>
<p>这个拓展是怎么做到的呢？可以在MetaData初始化的时候可以知道，MetaData是Java类的一个jni的容器，一个MetadataNode对应着一个类，通过MetadataNode可以对一个android类进行实例化，当然MetaData的初始化和反射起类的方式都需要靠asm去进行操作，这个是属于bingding-generator的范围，涉及了如何生成treeNodeStream.dat等的问题，这个不在这篇博客中叙述。但是需要明白的是，java的类和自己开发的类都在gradle的生成了对应的treeNodeStream.dat等三个二进制文件中，通过MetadataReader可以将其解析成对应的MetadataTreeNode和MetadataNode，利用MetadataNode去和其他类交互。</p>

<p>现在第一步了解了MetaData后可以来看一下加载MetadataNode的主要过程和上面提到的问题。
在Runtime.cpp中的PrepareV8Runtime方法中有MetadataNode::BuildMetadata的方法，这就是进行Metadata初始化的起点:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MetadataNode</span><span class="o">::</span><span class="n">BuildMetadata</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filesPath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">baseDir</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"/metadata"</span><span class="p">);</span>
	<span class="n">string</span> <span class="n">nodesFile</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">+</span> <span class="s">"/treeNodeStream.dat"</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">namesFile</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">+</span> <span class="s">"/treeStringsStream.dat"</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">valuesFile</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">+</span> <span class="s">"/treeValueStream.dat"</span><span class="p">;</span>
    <span class="p">...</span>
	<span class="n">BuildMetadata</span><span class="p">(</span><span class="n">lenNodes</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">lenNames</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">),</span> <span class="n">lenValues</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>
	<span class="k">delete</span><span class="p">[]</span> <span class="n">nodes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>可以看出，在BuildMetadata中就是做了加载三个dat二进制文件，接着，通过MetadataReader的BuildTree方法开始从二进制文件中读取node的基本信息，为后面加载类信息做基本准备。接着回到Runtime.cpp中，可以看到CreateTopLevelNamespaces方法，这个方法进行MetadataNode的初始化，从最顶层类开始往下。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MetadataNode</span><span class="o">::</span><span class="n">CreateTopLevelNamespaces</span><span class="p">(</span><span class="n">Isolate</span> <span class="o">*</span><span class="n">isolate</span><span class="p">,</span> <span class="k">const</span> <span class="n">Local</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;</span> <span class="n">global</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="n">s_metadataReader</span><span class="p">.</span><span class="n">GetRoot</span><span class="p">();</span>

	<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">children</span> <span class="o">=</span> <span class="o">*</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">treeNode</span> <span class="o">:</span> <span class="n">children</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">nodeType</span> <span class="o">=</span> <span class="n">s_metadataReader</span><span class="p">.</span><span class="n">GetNodeType</span><span class="p">(</span><span class="n">treeNode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">MetadataTreeNode</span><span class="o">::</span><span class="n">PACKAGE</span><span class="p">)</span>
		<span class="p">{</span>
		   <span class="c1">// 从treeNode上获取下一个node的信息
</span>			<span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">GetOrCreateInternal</span><span class="p">(</span><span class="n">treeNode</span><span class="p">);</span>
      <span class="c1">// 为node信息创建对应的js的obj 的创建模板FunctionTemplate
</span>			<span class="k">auto</span> <span class="n">packageObj</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">CreateWrapper</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
			<span class="c1">// 将js
</span>			<span class="n">global</span><span class="o">-&gt;</span><span class="n">Set</span><span class="p">(</span><span class="n">ArgConverter</span><span class="o">::</span><span class="n">ConvertToV8String</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">m_treeNode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="n">packageObj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>在CreateWrapper方法中，将会为每一个对应的类创建一个对应的模板FunctionTemplate，这个一个模板是能够向v8中注入相应的字段，通过字段作为js的一个新的类型，并通过此FunctionTemplate回调到jni方法，去进行相应的java obj和jni obj的初始化，并进行绑定。获得这个FunctionTemplate的方法是：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code>
</code></pre>
</div>
<p>(2)从Android端创建一个js端的NativeScriptActivity对应的MyActivity：</p>

<p>2.Android与JS间方法调用：
<img src="http://note.youdao.com/favicon.ico" alt="方法调用" />
创建了对象之后，那么调用方法也就是调用对象内部的方法，和上面的创建对象类似，但是是基于找到了对应的对象后利用jni和v8自身的机制去调用android和js的方法。</p>

<p>(1)从JS端对象调用方法，直接调用到对应的Android对象的方法：</p>

<p>(2)从Android端对象调用方法，直接调用到对应的js对象的方法。
小结：</p>

<h4 id="v8">v8</h4>
<p>就像上面说的一样，NativeScript的强大都是源于V8的神乎其技，v8鬼斧神工的代码实在难以琢磨，但是学会使用一些api也就能够很快的上手v8了。runtime里面就有很多使用v8 api的实例，是一个非常优秀的练功宝典。</p>

<p>Android webview注入Object方法就是通过动态寻找类方法方式进行，基于一个已经完整的js，其实也是基于v8进行注入，weex也是比这个简单，就是简单的额注入一些基本的方法，注入一个已知的类，然后通过一个暴露的接口进行交互。</p>

<h4 id="android-runtime的优缺点">android-runtime的优缺点</h4>
<ol>
  <li>
    <p>优点：</p>
  </li>
  <li>
    <p>缺点：</p>
  </li>
</ol>

<h4 id="说在最后">说在最后</h4>

<p>metadata:如何将类进行加载和转化为节点。</p>

<p>分为几个部分介绍：</p>
<ul>
  <li>nativeScript核心运行Runtime</li>
  <li>如何将类进行加载和转化为节点。</li>
  <li>v8接口</li>
  <li>js接口测试</li>
  <li>js调试</li>
  <li>android-runtime优缺点</li>
</ul>
" >
  </div>
  
  <div class="__vue-root" id="ArticleInfo" postTitle="Jekyll和Vue搭建自己的博客" postUrl="/post/Jekyll和Vue搭建自己的博客.html"
        postDate="March 1, 2017" postSynopsis="从前写CSDN，CSDN简单写完即走，还有评论排名阅读量，但是毕竟博客不是自己搭的，总有想要能自己掌控样式的时候。现在借用github这个大平台，搭建自己的博客，实践一下js和vue框架，让想了很久的想法落地，之后就好好写博客。文章包含了jekyll博客搭建，vue框架和jekyll结合等内容。"
        postSubTitle="" postContent="<h3>：</h3>
<p>XCore是给予前端展示界面Native化能力的框架，前端与Native的交互是XCore与生俱来的能力。对于创建新组件，我们强烈推荐使用现有的XCore API进行前端组件的拓展和封装。但是由于框架中现有的局限影响了你的开发，当框架中的拓展涉及了或者是不能满足，可以进行组件的Native拓展。
组件Native拓展指的是在xcore-vue中定义组件标签component，该component组件在Native端中对应一个View组件，改component的展示逻辑都有Native端的决定，</p>

<p>``` java
// 你好
public void func() {</p>

<p>}</p>
" >
  </div>
  
  <div class="__vue-root" id="ArticleInfo" postTitle="关于顶层const和底层const问题" postUrl="/jotting/关于顶层const和底层const问题.html"
        postDate="January 1, 2017" postSynopsis=""
        postSubTitle="" postContent="<p>As we’ve seen, a pointer is an object that can point to a different object. As a result,
we can talk independently about whether a pointer is const and whether the objects
to which it can point are const. We use the term top-level const to indicate that the
pointer itself is a const. When a pointer can point to a const object, we refer to
that const as a low-level const.</p>
" >
  </div>
  
</div>

<!-- Pager -->


<script>
  // 确保fixed 文字能够显示
  // var $mainPageHeader = document.querySelector(".main-page-header");
  // var $navigator = document.querySelector(".navigator-wrap");
  // window.onscroll = function () {
  //   // 当滚动到最底部以上100像素时， 加载新内容
  //   if (document.body.scrollTop > ($mainPageHeader.scrollHeight - $navigator.scrollHeight)) {
  //     $navigator.style.backgroundColor = "darkgray";
  //   } else {
  //     $navigator.style.backgroundColor = "transparent";
  //   }
  // };
</script>

	<footer>
  <div class="footer-container">
    <div class="theme-layout">
      <div>
        Theme by <a href="http://yxping.github.io/">yxp</a>&nbsp;&nbsp;|&nbsp;&nbsp;
      </div>
      <iframe src="https://ghbtns.com/github-btn.html?user=yxping&repo=yxping.github.io&type=star&count=true"
      frameborder="0" scrolling="0" width="80px" height="20px">
      </iframe>
    </div>
  </div>
</footer>

<!-- Vue Component -->
<script src="/assets/bundle.js"></script>

<script type="text/javascript">
  var duoshuoQuery = {short_name:"yxpeng"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
  <!-- 多说公共JS代码 end -->
</script>

</body>
</html>
